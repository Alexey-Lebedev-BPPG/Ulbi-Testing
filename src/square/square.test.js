const square = require("./square");
const squarePow = require("./squarePow");

describe("square", () => {
  // в describe перед каждым запуском каждого теста мы можем проводить какие-то операции в beforeEach
  let mockValue;
  beforeEach(() => {
    mockValue = Math.random();
  });
  // чтоб провести что-то один раз перед запуском всех тестов, используем beforeAll
  beforeAll(() => {});

  test("Корректное значение", () => {
    expect(square(2)).toBe(4);
    // определяем, что результат меньше 5
    expect(square(2)).toBeLessThan(5);
    // определяем, что результат больше 3
    expect(square(2)).toBeGreaterThan(3);
    // определяем, что результат не равен undefined
    expect(square(2)).not.toBeUndefined();

    // эта методика предоставляет возможность мокать какие-либо методы в функциях. Например, у нас мы создали переменную,
    // в которую поместили вызов нашего метода. После этого мы вызываем нашу функцию с аргументом два.потом замоконную
    // функцию мы передаем в expect и с помощью toBeCalledTimes проверем, сколько раз сработает функция (мы указали, что
    // функция сработает один раз)
    const spyMathPow = jest.spyOn(Math, "pow");
    squarePow(2);
    expect(spyMathPow).toBeCalledTimes(1);
    // если вызвать подобную конструкцию ниже еще раз, то тест упадет с ошибкой, т.к. моковые переменные накапливают в
    // себе данные вызовов. Поэтому их нужно очищать после каждого запуска тестов (например в блоке afterEach)
  });

  // провоцируем еще один тест, чтоб проверить очищение моков
  test("Корректное значение", () => {
    const spyMathPow = jest.spyOn(Math, "pow");
    squarePow(1);
    // метод должен сработать 0 раз, т.к. при единице у нас функция его не вызывает, а просто возвращает 1
    expect(spyMathPow).toBeCalledTimes(0);
  });

  // анологичные есть функции, которые запускаются после каждого теста или после всех тестов
  afterEach(() => {
    // очищаем все наши моки
    jest.clearAllMocks();
  });
  afterAll(() => {});
});
